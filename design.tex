\documentclass[]{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\author{}
\date{}

\begin{document}

\section{Wee Dig Dug: Design}\label{wee-dig-dug-design}

\subsection{Overview}\label{overview}

The game is designed similar to a \textbf{Model-View-Controller (MVC)}
framework. This architecture is a common way of designing applications
with a User Interface. A \textbf{MVC} framework works in the following
way:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Each component is responsible for a particular task, and only that
  component is allowed to perform that task.
\item
  The \textbf{Model} is the internal representation of the application,
  and it is responsible to maintain the state of the application at any
  time.
\item
  The \textbf{View} is the GUI. It works by reading the \textbf{Model}
  and displaying the graphical representation of the model on the
  screen.
\item
  The \textbf{Controller} is the component that is responsible for
  listening to user input and updating the model accordingly.
\item
  \textbf{MVC} components interact with each other the following way:
\end{itemize}

\texttt{TODO: Insert MVC image}

\subsection{Controller (controller.s)}\label{controller-controller.s}

The \textbf{Controller} mainly contains interrupt handlers, and it is
also the entry point for the game. In is, we do the following:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Initialize timer and timer match registers for periodic interrupts.
\item
  Listen for UART0 interrupt, read the keystrokes and perform the
  corresponding action
\item
  Listen for External Interrupt Button press and PAUSE the game.
\end{itemize}

The controller is a relatively small component, responsible mainly for
updating the \textbf{Model} via subroutines exposed by the
\textbf{Model}.

\subsection{Model (model.s)}\label{model-model.s}

The \textbf{Model} maintains the internal representation of the board
and triggers \textbf{View} updates. It exposed routines that allows the
\textbf{Controller} to trigger updates on the \textbf{Model}.

\subsubsection{Implementation}\label{implementation}

The \textbf{Model} consists of an \textbf{``array''} (created using the
\texttt{FILL} directive) of size 19 X 15 bytes, each byte representing a
grain of sand. The \textbf{Model} also consists of \texttt{DCD} tables
to hold information of sprites. These tables are structured similar to C
\texttt{struct}s. They look like this:

\begin{verbatim}
SPRITE
    DCD [0-18]  ; Holds X coordinate of the sprite
    DCD [0-14]  ; Holds Y coordinate of the sprite
    DCD {1,4}   ; Holds Number of lives the sprite has
    DCD [0-3]   ; Code for direction the sprite is moving/facing
    DCD [0-18]  ; Previous X coordinate of sprite
    DCD [0-14]  ; Previous Y coordinate of sprite
    DCD [0-18]  ; Original X position (to reset when respawning)
    DCD [0-14]  ; Original Y position
\end{verbatim}

\subsubsection{Uses}\label{uses}

The model will maintain the following information:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Position and state of all sprites on board
\item
  Position of all the sand using an array
\item
  Score/Level
\end{enumerate}

\subsubsection{Subroutines}\label{subroutines}

The model contains subroutines that will:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Initialize model (board and sprites)
\item
  Manipulate model

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    Reset model
  \item
    Remove sprite
  \item
    Change sprite direction
  \item
    Remove sand and change score
  \end{itemize}
\end{itemize}

\subsubsection{Design}\label{design}

The model consists of:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  The board: 40 X 64 array of ``blocks''.

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    The board is a 40 X 64 byte array of blocks, each byte representing
    a boolean for sand, i.e, 1 = ``sand'' and 0 = ``no sand''.
  \item
    The array is created by reserving 40*64 = 2560 bytes of space in
    static memory by using the SPACE or FILL directives.
  \item
    \textbf{NOTE:} The size of the array can be changed to make the game
    more space efficient. This can be addressed in later versions of the
    game
  \item
    \textbf{NOTE:} The size of the board can be changed also, as the
    final game should work regardless of size.
  \end{itemize}
\item
  The sprites:

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    Each type of sprite (Dug, his pump, Pookas and Fygars) maintains a
    position (the top left corner in GUI) and a state, (direction of
    movement, velocity, DEAD or not).
  \item
    The character sprites (Dug, the Pookas and the Fygars) are each of
    size 4 X 4 blocks (hence occupying 16 blocks).
  \item
    Dug's pump is a sprite of height 1 block and variable length. This
    sprite has an additional state variable to hold length. The length
    cannot exceed 4 blocks (\textbf{NOTE:} To be revised).
  \end{itemize}
\end{enumerate}

\subsection{gui.s}\label{gui.s}

The GUI reads the model and displays it.

\subsubsection{Uses}\label{uses-1}

The GUI is responsible for the following:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Maintain the state of the screen, i.e., hold representation for Main
  Menu and Game
\item
  Update itself as and when model is updated.
\item
  Maintain a accurate representation of the model.
\end{itemize}

\subsubsection{Subroutines}\label{subroutines-1}

The GUI file will have subroutines that will:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Draw GUI
\item
  Update GUI
\end{itemize}

\subsubsection{Design}\label{design-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Sand:

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    Each block in the model represents one block of sand in the GUI.
  \item
    The sand is 4 X 4 ``pixels'' in the GUI.
  \end{itemize}
\item
  Character Sprites:

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    Each character sprite is 16 X 16 ``pixels'' in the GUI.
  \end{itemize}
\item
  Draw/Update:

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    The draw and update subroutines will print all variables in the
    model based on the pre-defined size of the sprites.
  \end{itemize}
\end{enumerate}

\subsection{controller.s}\label{controller.s}

The controller is the module that will control both, the GUI and the
model. It will mainly contain:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  The interrupt handlers for user input and timer.
\item
  Collision detection subroutine
\item
  Update sprite positions subroutine
\item
  Generate pump subroutine.
\end{itemize}

\subsubsection{Design:}\label{design-2}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  For user input:

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    Use FIQ Interrupts to handle user input/keystrokes, as implemented
    in Lab 6.
  \end{itemize}
\item
  For game update:

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    On timer interrupt, the controller has to perform collision
    detection and handling, and update position of sprites.
  \end{itemize}
\end{enumerate}

\paragraph{Detecting collisions:}\label{detecting-collisions}

The controller will detect collision detection by the following simple
procedure: * Read coordinate of each sprite in the model. * For each
sprite, do the following: * For the Dug Sprite: * Sum up the byte values
of all the blocks occupied by Dug on the Game board. Add to High Score.
* Set all blocks occupied by Dug to 0 * If blocks occupied by Dug
overlap with that of either of the Pookas or Fygars, decrement Dug's
life by 1, reset game. * If collision with wall, do not update position.
* For the enemy sprites: * If collision with wall, set random direction.

\end{document}
